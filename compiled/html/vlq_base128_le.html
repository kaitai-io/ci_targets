
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

    <title>VlqBase128Le format specification</title>
  </head>
  <body>
           <div class="container">
  <h1>VlqBase128Le format specification</h1>

      
<a name='type-vlq_base128_le'></a>
<h1>Type: VlqBase128Le</h1>

<p>A variable-length unsigned/signed integer using base128 encoding. 1-byte groups
consist of 1-bit flag of continuation and 7-bit value chunk, and are ordered
"least significant group first", i.e. in "little-endian" manner.

This particular encoding is specified and used in:

* DWARF debug file format, where it's dubbed "unsigned LEB128" or "ULEB128".
  <https://dwarfstd.org/doc/dwarf-2.0.0.pdf> - page 139
* Google Protocol Buffers, where it's called "Base 128 Varints".
  <https://protobuf.dev/programming-guides/encoding/#varints>
* Apache Lucene, where it's called "VInt"
  <https://lucene.apache.org/core/3_5_0/fileformats.html#VInt>
* Apache Avro uses this as a basis for integer encoding, adding ZigZag on
  top of it for signed ints
  <https://avro.apache.org/docs/1.12.0/specification/#primitive-types-1>

More information on this encoding is available at <https://en.wikipedia.org/wiki/LEB128>

This particular implementation supports integer values up to 64 bits (i.e. the
maximum unsigned value supported is `2**64 - 1`), which implies that serialized
values can be up to 10 bytes in length.

If the most significant 10th byte (`groups[9]`) is present, its `has_next`
must be `false` (otherwise we would have 11 or more bytes, which is not
supported) and its `value` can be only `0` or `1` (because a 9-byte VLQ can
represent `9 * 7 = 63` bits already, so the 10th byte can only add 1 bit,
since only integers up to 64 bits are supported). These restrictions are
enforced by this implementation. They were inspired by the Protoscope tool,
see <https://github.com/protocolbuffers/protoscope/blob/8e7a6aafa2c9958527b1e0747e66e1bfff045819/writer.go#L644-L648>.
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>groups</td>
<td><a href="#type-vlq_base128_le-group">Group</a></td>
<td></td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(len),List(instances, len),Attribute(Name(identifier(groups)),identifier(size)),None,Some(CalcIntType),DocSpec(None,List()))
value instance: ValueInstanceSpec(InstanceIdentifier(sign_bit),List(instances, sign_bit),CastToType(IfExp(Compare(Name(identifier(len)),Eq,IntNum(10)),IntNum(9223372036854775808),BinOp(Attribute(Attribute(Name(identifier(groups)),identifier(last)),identifier(multiplier)),Mult,IntNum(64))),typeId(false,List(u8),false)),None,Some(IntMultiType(false,Width8,None)),DocSpec(None,List()))
value instance: ValueInstanceSpec(InstanceIdentifier(value),List(instances, value),Attribute(Attribute(Name(identifier(groups)),identifier(last)),identifier(interm_value)),None,Some(IntMultiType(false,Width8,None)),DocSpec(Some(Resulting unsigned value as normal integer),List()))
value instance: ValueInstanceSpec(InstanceIdentifier(value_signed),List(instances, value_signed),IfExp(BoolOp(And,List(Compare(Name(identifier(sign_bit)),Gt,IntNum(0)), Compare(Name(identifier(value)),GtE,Name(identifier(sign_bit))))),UnaryOp(Minus,CastToType(BinOp(Name(identifier(sign_bit)),Sub,BinOp(Name(identifier(value)),Sub,Name(identifier(sign_bit)))),typeId(false,List(s8),false))),CastToType(Name(identifier(value)),typeId(false,List(s8),false))),None,Some(IntMultiType(true,Width8,None)),DocSpec(None,List()))
<a name='type-vlq_base128_le-group'></a>
<h2>Type: Group</h2>

<p>One byte group, clearly divided into 7-bit "value" chunk and 1-bit "continuation" flag.
</p>
<table class="table">
<tr><th>Offset</th><th>Size</th><th>ID</th><th>Type</th><th>Note</th></tr>
<tr>
<td>0</td>
<td>...</td>
<td>has_next</td>
<td>b1beâ†’bool</td>
<td>If `true`, then we have more bytes to read.

Since this implementation only supports serialized values up to 10
bytes, this must be `false` in the 10th group (`groups[9]`).
</td>
</tr>
<tr>
<td>0:1</td>
<td>...</td>
<td>value</td>
<td>b7be</td>
<td>The 7-bit (base128) numeric value chunk of this group

Since this implementation only supports integer values up to 64 bits,
the `value` in the 10th group (`groups[9]`) can only be `0` or `1`
(otherwise the width of the represented value would be 65 bits or
more, which is not supported).
</td>
</tr>
</table>
value instance: ValueInstanceSpec(InstanceIdentifier(interm_value),List(types, group, instances, interm_value),CastToType(BinOp(Name(identifier(prev_interm_value)),Add,BinOp(Name(identifier(value)),Mult,Name(identifier(multiplier)))),typeId(false,List(u8),false)),None,Some(IntMultiType(false,Width8,None)),DocSpec(None,List()))

  </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  </body>
</html>
      
